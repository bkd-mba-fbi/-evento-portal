import { functionValue } from './functionValue.js';
import { StateEvent } from './state-event.js';
/**
 * Change function that returns true if `value` is different from `oldValue`.
 * This method is used as the default for a property's `hasChanged` function.
 */
export const notEqual = (value, old) => {
    // This ensures (old==NaN, value==NaN) always returns false
    return old !== value && (old === old || value === value);
};
/**
 * A state, firing `lit-state-change` when any of it property changes
 *
 */
class State extends EventTarget {
    // a map holding decorators definition.
    static propertyMap;
    static properties;
    static finalized = false;
    get propertyMap() {
        return this.constructor.propertyMap;
    }
    get stateValue() {
        return Object.fromEntries([...this.propertyMap].map(([key]) => [key, this[key]]));
    }
    // hold a reference to hooks
    hookMap = new Map();
    constructor() {
        super();
        this.constructor.finalize();
        // make sure all getter and setters are called once as some work is 
        // being done in @decorator getter and setter. For instance, @storage 
        // stores the value to local storage in setter.
        if (this.propertyMap) {
            [...this.propertyMap].forEach(([key, definition]) => {
                if (definition.initialValue !== undefined) {
                    const value = functionValue(definition.initialValue);
                    this[key] = value;
                    definition.value = value;
                }
            });
        }
    }
    static finalize() {
        if (this.finalized) {
            return false;
        }
        this.finalized = true;
        const propKeys = Object.keys(this.properties || {});
        // This for/of is ok because propKeys is an array
        for (const p of propKeys) {
            // note, use of `any` is due to TypeScript lack of support for symbol in
            // index types
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.createProperty(p, this.properties[p]);
        }
        return true;
    }
    static createProperty(name, options) {
        // Note, since this can be called by the `@property` decorator which
        // is called before `finalize`, we ensure finalization has been kicked off.
        this.finalize();
        const key = typeof name === 'symbol' ? Symbol() : `__${name}`;
        const descriptor = this.getPropertyDescriptor(name, key, options);
        Object.defineProperty(this.prototype, name, descriptor);
    }
    static getPropertyDescriptor(name, key, options) {
        const hasChanged = options?.hasChanged || notEqual;
        return {
            get() { return this[key]; },
            set(value) {
                const oldValue = this[name];
                this[key] = value;
                if (hasChanged(value, oldValue) === true) {
                    this.dispatchStateEvent(name, value, this);
                }
                ;
            },
            configurable: true,
            enumerable: true,
        };
    }
    /**
     * Reset the state to its original values, skipping
     * properties marked as skipReset
     */
    reset() {
        // reset all hooks first;
        this.hookMap.forEach(hook => hook.reset());
        [...this.propertyMap]
            // @ts-ignore
            .filter(([key, definition]) => !(definition.skipReset === true || definition.resetValue === undefined))
            .forEach(([key, definition]) => {
            this[key] = definition.resetValue;
        });
    }
    /**
     * subscribe to state change event. The callback will be called anytime
     * a state property change if `nameOrNames` is undefined, or only for matching
     * property values specified by `nameOrNames`
     * @param callback the callback function to call
     * @param nameOrNames
     * @returns a unsubscribe function.
     */
    subscribe(callback, nameOrNames, options) {
        if (nameOrNames && !Array.isArray(nameOrNames)) {
            nameOrNames = [nameOrNames];
        }
        const cb = (event) => {
            if (!nameOrNames || nameOrNames.includes(event.key)) {
                callback(event.key, event.value, this);
            }
        };
        this.addEventListener(StateEvent.eventName, cb, options);
        return () => this.removeEventListener(StateEvent.eventName, cb);
    }
    dispatchStateEvent(key, eventValue, state) {
        this.dispatchEvent(new StateEvent(key, eventValue, state));
    }
}
export { State };
//# sourceMappingURL=state.js.map