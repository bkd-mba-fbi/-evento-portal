{"version":3,"file":"property.js","sourceRoot":"","sources":["property.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,gBAAgB,EAAE,MAAM,0CAA0C,CAAC;AAuC5E,MAAM,UAAU,QAAQ,CAAC,OAAyB;IACjD,2CAA2C;IAC1C,OAAO,gBAAgB,CAAC;QACxB,gEAAgE;QAC9D,QAAQ,EAAE,CAAC,IAAkB,EAAE,IAAY,EAAE,EAAE;YAChD,kCAAkC;YAE/B,IAAG,MAAM,CAAC,wBAAwB,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,EAAE;gBAC5D,MAAM,IAAI,KAAK,CAAC,sDAAsD,CAAC,CAAA;aACvE;YAAA,CAAC;YAEF,IAAG,CAAC,IAAI,CAAC,WAAW,EAAE;gBACrB,IAAI,CAAC,WAAW,GAAG,IAAI,GAAG,EAA8B,CAAA;aACxD;YACD,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,EAAE,EAAC,GAAG,OAAO,EAAE,GAAG,EAAC,YAAY,EAAE,OAAO,EAAE,KAAK,EAAE,UAAU,EAAE,OAAO,EAAE,KAAK,EAAC,EAAC,CAAC,CAAA;YACvG,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,EAAE,OAAO,CAAE,CAAA;QACzC,CAAC;KACH,CAAiC,CAAA;AAEnC,CAAC","sourcesContent":["\nimport { State, PropertyMapOptions} from '../state.js'\nimport { decorateProperty } from '@lit/reactive-element/decorators/base.js';\n\nexport type PropertyTypes = Array<unknown> | Boolean | Object | String | Number\n/**\n * Defines options for a property.\n */\nexport type PropertyOptions =  {\n\n  /**\n   * The value to initiate the state with\n   */\n  value?: unknown;\n\n  /**\n   * State.reset reset all property values to their initial {value: value}\n   * value. This is not the wanted behavior in some cases. For instance, we can\n   * have a state property for language, with an initial value (english). The \n   * state will be reset on user sign-out, but we want to keep the actual \n   * state value for language, if the user has modified it. \n   */\n  skipReset?: boolean\n\n  /** \n   * the type of the property. Used to Stringify/parse depending on wich \n   * other decorators are in use. For instance, @storage strignify before\n   * storing to localStorage. \n   */\n  type?: PropertyTypes;\n\n  /**\n   * A function that indicates if a property should be considered changed when\n   * it is set. The function should take the `newValue` and `oldValue` and\n   * return `true` if an update should be requested.\n   */\n  hasChanged?(value: unknown, oldValue: unknown): boolean;\n}\n\nexport type PropertySignature = (protoOrDescriptor: State, name?: string | undefined) => any\n\nexport function property(options?: PropertyOptions) {\n\t// console.info('property options',options)\n  return decorateProperty({\n\t\t// @ts-ignore ctor is typof State and not typeof ReactiveElement\n    finisher: (ctor: typeof State, name: string) => {\n\t\t\t// console.info('property ', name)\n\n      if(Object.getOwnPropertyDescriptor(ctor.prototype, name)) {\n\t\t\t\tthrow new Error('@property must be called before all state decorators')\n\t\t\t};\n\n\t\t\tif(!ctor.propertyMap) {\n\t\t\t\tctor.propertyMap = new Map<string, PropertyMapOptions>()\n\t\t\t}\n\t\t\tctor.propertyMap.set(name, {...options, ...{initialValue: options?.value, resetValue: options?.value}}) \n\t\t\treturn ctor.createProperty(name, options )\n    }\n\t}) as unknown as PropertySignature\n    \n}\n"]}