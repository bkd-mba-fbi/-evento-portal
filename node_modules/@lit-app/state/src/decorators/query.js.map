{"version":3,"file":"query.js","sourceRoot":"","sources":["query.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,gBAAgB,EAAE,MAAM,0CAA0C,CAAC;AAE5E,OAAO,EAAE,aAAa,EAAE,MAAM,qBAAqB,CAAC;AACpD,OAAO,EAAE,KAAK,EAAE,MAAM,YAAY,CAAC;AAOnC,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAA;AAEzC;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH,MAAM,UAAU,KAAK,CAAC,OAAsB;IAE3C,OAAO,gBAAgB,CAAC;QACvB,gEAAgE;QAChE,QAAQ,EAAE,CAAC,IAAkB,EAAE,IAAY,EAAE,EAAE;YAE9C,MAAM,UAAU,GAAG,MAAM,CAAC,wBAAwB,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;YACzE,IAAI,CAAC,UAAU,EAAE;gBAChB,MAAM,IAAI,KAAK,CAAC,4DAA4D,CAAC,CAAA;aAC7E;YACD,MAAM,SAAS,GAAW,GAAG,OAAO,EAAE,SAAS,IAAI,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC;YAClE,MAAM,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAC9C,MAAM,IAAI,GAAG,UAAU,EAAE,IAAI,CAAA;YAC7B,IAAG,UAAU,EAAE;gBACd,MAAM,aAAa,GAAG,UAAU,CAAC,YAAY,CAAA;gBAC7C,MAAM,cAAc,GAAG,GAAG,CAAC,YAAY,CAAC,GAAG,CAAC,SAAS,CAAC,CAAA;gBAEtD,mEAAmE;gBACnE,IAAG,cAAc,KAAK,IAAI,EAAE;oBAC3B,UAAU,CAAC,SAAS,GAAG,IAAI,CAAA;iBAC3B;gBACD,UAAU,CAAC,YAAY,GAAG,GAAG,EAAE,CAAC,KAAK,CAAC,cAAc,EAAE,IAAI,CAAC,IAAI,aAAa,CAAC,aAAa,CAAC,CAAC;gBAC5F,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,EAAE,EAAC,GAAG,UAAU,EAAE,GAAG,OAAO,EAAC,CAAC,CAAA;aACvD;QACF,CAAC;KACD,CAAiC,CAAA;AACnC,CAAC","sourcesContent":["\nimport {State } from '../state.js'\nimport { decorateProperty } from '@lit/reactive-element/decorators/base.js';\nimport { PropertySignature } from './property.js';\nimport { functionValue } from '../functionValue.js';\nimport { parse } from './parse.js';\n\nexport type QueryOptions = {\n\tparameter?: string,\n\tskipAsync?: boolean\n}\n\nconst url = new URL(window.location.href)\n\n/**\n * A decorator for setting state values from url parameters\n * \n * Used together with @storage, it allows to persist such values. \n * @query must be placed before @storage for this to work.\n * \n *  * How to use: \n * ```js\n * class MyState extends State {\n * \t\n *   @query({parameter: 'para'})\n *   @storage({key: 'storage_path'})\n *   @property({value: 1}) a;\n * }\n * const s = new S()\n * \n * localStorage.getItem('_ls_storage_path') \n * \n * ```\n * @param options \n * @returns \n */\nexport function query(options?: QueryOptions) {\n\n\treturn decorateProperty({\n\t\t// @ts-ignore ctor is typof State and not typeof ReactiveElement\n\t\tfinisher: (ctor: typeof State, name: string) => {\n\t\t\n\t\t\tconst descriptor = Object.getOwnPropertyDescriptor(ctor.prototype, name);\n\t\t\tif (!descriptor) {\n\t\t\t\tthrow new Error('@local-storage decorator need to be called after @property')\n\t\t\t}\n\t\t\tconst parameter: string = `${options?.parameter || String(name)}`;\n\t\t\tconst definition = ctor.propertyMap.get(name);\n\t\t\tconst type = definition?.type\n\t\t\tif(definition) {\n\t\t\t\tconst previousValue = definition.initialValue\n\t\t\t\tconst parameterValue = url.searchParams.get(parameter)\n\n\t\t\t\t// register the fact that this property is set by a query parameter\n\t\t\t\tif(parameterValue !== null) {\n\t\t\t\t\tdefinition.skipAsync = true\n\t\t\t\t}\n\t\t\t\tdefinition.initialValue = () => parse(parameterValue, type) ?? functionValue(previousValue);\n\t\t\t\tctor.propertyMap.set(name, {...definition, ...options})\n\t\t\t}\n\t\t}\n\t}) as unknown as PropertySignature\n}\n\n"]}