{"version":3,"file":"state.js","sourceRoot":"","sources":["state.ts"],"names":[],"mappings":"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","sourcesContent":["import { functionValue } from './functionValue.js';\nimport { StateEvent } from './state-event.js';\nimport { Hook } from './hook.js';\nimport { PropertyOptions } from './decorators/property.js';\nimport { StorageOptions } from './decorators/storage.js';\nimport { QueryOptions } from './decorators/query.js';\n\nexport interface HasChanged {\n  (value: unknown, old: unknown): boolean;\n}\n\nexport interface Unsubscribe {\n  (): void\n}\n\n/**\n * Change function that returns true if `value` is different from `oldValue`.\n * This method is used as the default for a property's `hasChanged` function.\n */\nexport const notEqual: HasChanged = (value: unknown, old: unknown): boolean => {\n  // This ensures (old==NaN, value==NaN) always returns false\n  return old !== value && (old === old || value === value);\n};\n\nexport type PropertyMapOptions = PropertyOptions &\n  StorageOptions &\n  QueryOptions &\n{ initialValue: any, hook?: { [key: string]: any }, resetValue: any }\n\n/**\n * Callback function - used as callback subscription to a state change \n */\nexport type Callback = (key: string, value: any, state: State) => void\n\n/**\n * A state, firing `lit-state-change` when any of it property changes\n *  \n */\nexport class State extends EventTarget {\n\n  // a map holding decorators definition.\n  static propertyMap: Map<string, PropertyMapOptions>\n\n  static properties: PropertyOptions;\n  static finalized: boolean = false;\n\n  get propertyMap() {\n    return (this.constructor as typeof State).propertyMap\n  }\n\n  get stateValue() {\n    return Object.fromEntries([...this.propertyMap].map(([key]) => [key, (this as {} as { [key: string]: unknown })[key as string]]))\n  }\n\n  // hold a reference to hooks\n  hookMap: Map<string, Hook> = new Map()\n\n  constructor() {\n    super();\n    (this.constructor as typeof State).finalize();\n    // make sure all getter and setters are called once as some work is \n    // being done in @decorator getter and setter. For instance, @storage \n    // stores the value to local storage in setter.\n    if (this.propertyMap) {\n      [...this.propertyMap].forEach(([key, definition]) => {\n        if (definition.initialValue !== undefined) {\n          const value: any = functionValue(definition.initialValue);\n          (this as {} as { [key: string]: unknown })[key as string] = value;\n          definition.value = value;\n        }\n      })\n    }\n  }\n\n  protected static finalize() {\n    if (this.finalized) {\n      return false;\n    }\n    this.finalized = true;\n    const propKeys = Object.keys(this.properties || {})\n    // This for/of is ok because propKeys is an array\n    for (const p of propKeys) {\n      // note, use of `any` is due to TypeScript lack of support for symbol in\n      // index types\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this.createProperty(p, (this.properties as any)[p]);\n    }\n    return true\n  }\n\n  static createProperty(\n    name: string,\n    options?: PropertyOptions\n  ) {\n    // Note, since this can be called by the `@property` decorator which\n    // is called before `finalize`, we ensure finalization has been kicked off.\n    this.finalize();\n    const key = typeof name === 'symbol' ? Symbol() : `__${name}`;\n    const descriptor = this.getPropertyDescriptor(name, key, options);\n    Object.defineProperty(this.prototype, name, descriptor);\n  }\n\n  protected static getPropertyDescriptor(\n    name: string,\n    key: string | symbol,\n    options?: PropertyOptions\n  ): PropertyDescriptor {\n    const hasChanged = options?.hasChanged || notEqual\n\n    return {\n      get(): unknown { return (this as {} as { [key: string]: unknown })[key as string] },\n      set(this: State, value: unknown) {\n        const oldValue = (this as {} as { [key: string]: unknown })[\n          name as string\n        ];\n        (this as {} as { [key: string]: unknown })[key as string] = value;\n        if (hasChanged(value, oldValue) === true) {\n          this.dispatchStateEvent(name, value, this);\n        };\n      },\n      configurable: true,\n      enumerable: true,\n    };\n\n  }\n\n  /**\n   * Reset the state to its original values, skipping \n   * properties marked as skipReset\n   */\n  reset() {\n    // reset all hooks first;\n    this.hookMap.forEach(hook => hook.reset());\n\n    [...this.propertyMap]\n      // @ts-ignore\n      .filter(([key, definition]) => !(definition.skipReset === true || definition.resetValue === undefined))\n      .forEach(([key, definition]) => {\n          (this as {} as { [key: string]: unknown })[key as string] = definition.resetValue;\n      })\n  }\n\n  /**\n   * subscribe to state change event. The callback will be called anytime \n   * a state property change if `nameOrNames` is undefined, or only for matching\n   * property values specified by `nameOrNames`\n   * @param callback the callback function to call\n   * @param nameOrNames \n   * @returns a unsubscribe function. \n   */\n  subscribe(callback: Callback, nameOrNames?: string | string[], options?: AddEventListenerOptions): Unsubscribe {\n\n    if (nameOrNames && !Array.isArray(nameOrNames)) {\n      nameOrNames = [nameOrNames]\n    }\n    const cb = (event: StateEvent) => {\n      if (!nameOrNames || (nameOrNames as string[]).includes(event.key)) {\n        callback(event.key, event.value, this)\n      }\n    }\n    this.addEventListener(StateEvent.eventName, cb as EventListener, options)\n    return () => this.removeEventListener(StateEvent.eventName, cb as EventListener)\n  }\n\n  private dispatchStateEvent(key: string, eventValue: unknown, state: State) {\n    this.dispatchEvent(new StateEvent(key, eventValue, state))\n  }\n}\n\n\n"]}